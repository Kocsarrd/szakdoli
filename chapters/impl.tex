\chapter{Fejlesztői dokumentáció} % Developer guide
\label{ch:impl}

\section{A fejlesztői dokumentáció felépítése}

A fejlesztői dokumentáció három nagy részből áll. 

A 3.2 részben ismertetésre kerülnek a szoftver készítése során felhasznált technológiák, valamint nagy vonalakban a szoftver logikai felépítése. (Milyen programkomponensek vannak, milyen feladatokat látnak el, hogyan kapcsolódnak egymáshoz.) 

A 3.3 rész tartalmazza az egyes komponensek részletesebb leírását. Minden komponens esetén ismertetésre kerül a más komponensek felé nyilvánosságra hozott interfész, valamint a komponensek működési elve, beleértve a használt típusok leírását és a fontosabb algoritmusok működési elvét. A rész sorrendileg úgy van felépítve, hogy először szerepelnek a vezérlő komponens (\textit{App}) által használt komponensek leírásai, majd ezt követően a fő komponens. Így "lentről fölfelé" haladva először meg lehet érteni az egyes kisebb részek működését, majd azok segítségével az egész alkalmazás működését.

A 3.4 rész tartalmazza a tesztelési eljárás leírását és a tesztelés eredményeit. 

\section{A szoftver felépítése}

\subsection{Felhasznált technológiák összefoglalása}

Az alkalmazás Haskell nyelven íródott. A grafikus megjelenítés \textit{GTK+} alapú, a \textit{gtk2hs} csomag által biztosított bindingokat használtam a grafikus felület kezeléséhez. Ez a csomag a \textit{GTK+} osztályhierarchiáját Haskell típusosztályok hierarchiájaként adja vissza. Az egyes osztályok metódusainak a típusosztályok definíciójában szereplő függvények felelnek meg. A \textit{GTK+} típusai foreign pointerek segítségével vannak megvalósítva, és \textit{IO}-ban használhatók. 

Az alkalmazás a \textit{GTK+} logikájának megfelelően eseményvezérelt. A felhasználó akciói eseményeket váltanak ki, amelyek hatására handlerek futnak le. A handlerek minden esetben \textit{IO} akciók, amelyek valamilyen módon módosítják a globális állapotot (lásd 3.2.1. Globális állapot). A szoftver fejlesztése során fontos volt, hogy minél kevesebb legyen az tisztátalan (impure), \textit{IO}-n belül elvégzett számítás. Igyekeztem a program logikájának minél nagyobb részét egy tiszta, nem monadikus környezetben megvalósítani. Így a számítások helyessége könnyebben tesztelhető/verifikálható, a handlerek már keveset számolnak az \textit{IO}-ban.

Az alkalmazás a parseolási feladatokhoz a \textit{parsec} csomagot, a gráfok kezeléséhez az \textit{fgl} csomagot, a ghci futtatásához pedig a \textit{ghcid} csomagot használja. A modell adatainak könnyebb kezeléséhez a \textit{microlens-platform} csomagot használtam, ami a jól ismert \textit{lens} csomag egy kevesebb funkciót és kevesebb függőséget tartalmazó változata. A függőségek pontos listája elérhető a Felhasználói dokumentációban, illetve az egyes programkomponensek részletes leírásakor is említésre kerülnek a fontosabb felhasznált csomagok.

\subsection{A globális állapot}

Az alkalmazás fő felépítését egy az FP Complete blogján megjelent cikk \textbf{(IDE KÉNE EGY REFERENCIA)} inspirálta. 
Az alkalmazás a globális (olvasható) állapotot a \textit{ReaderT} monád transzformer segítségével valósítja meg, az alkalmazás vezérlése így egy \textit{ReaderT Env IO} környezetben történik, ahol \textit{Env} a globális állapotot leíró adattípus. Fontos megjegyezni, hogy bár az \textit{Env} típus komponensei az inicializálás után sosem módosulhatnak, a mögöttes állapot még változhat, hiszen a komponensek módosítható referenciák. Ez nagyon hasonló a Java nyelvben használható konstans referencia koncepciójához: a referencia nem változhat, de a referált adat igen.

A fentebb referált cikk által inspirálva a (GUI komponensein kívüli) globális állapot egy \textit{StateT} transzformer helyett módosítható referenciákkal (\textit{IORef} és \textit{MVar}) kezeltetik. Ugyanis hiába tiszta, ha globálisan használjuk a \textit{StateT}-t, valójában -- a programlogika szintjén -- ugyanúgy egy globális, módosítható állapotot vezetünk be. Szintén egy szempont, hogy a \textit{GTK+} alapú \textit{GUI} miatt eleve szerepelnek módosítható referenciák (foreign pointer) a globális állapotban, így ez a probléma semmiképpen nem kerülhető el teljesen. Egy további érv a globális \textit{StateT} ellen, hogy egy nagyobb monad stack szükségszerűen bonyolítja a programot. A \textit{ReaderT IO} ellenben még kifejezetten könnyen kezelhető. A cikk konkurrenciához köthető problémákat is említ a \textit{StateT}-vel kapcsolatban. Ez a szoftver jelenlegi verziójában még nem olyan jelentős (lévén a mostani implementáció nagyon kis mértékben épít konkurrenciára). Azonban a jövőre nézve mindenképpen előnyös, ha a szoftvert könnyen lehet a konkurrens paradigma szerint bővíteni.

Ezen bevezető után tekintsük a globális állapot definícióját! Az alábbi típusdefiníció az \textit{App.Types} modulban található:
\lstset{caption={Az Env típus}, label=src:hs}
\begin{lstlisting}[language={Haskell}, label=src:env]
data EvalConfig = EvalConfig { modules :: [String]
                             , paths :: [String]
                             }
  deriving (Eq, Generic)

data EvalControl = EvalControl { eGhci    :: MVar Ghci
                               , eCommand :: MVar String
                               , eResult  :: MVar (Either String [String])
                               , eConfig  :: MVar EvalConfig 
                               } deriving Eq

data SaveStatus = Saved | Modified
  deriving Eq

data File = File FilePath SaveStatus
  deriving Eq
  
data Env = Env { evalControl  :: EvalControl
               , gui          :: Gui
               , state        :: IORef Spreadsheet
               , file         :: IORef (Maybe File)
               } deriving Eq
\end{lstlisting}

Az \textit{evalControl} mező tartalmazza a kifejezések ghci-ban való kiértékelés hez szükséges erőforrásokat. Az \textit{eConfig} mező tartalmazza a GHCi-hoz tartozó konfigurációs beállításokat. (Betöltött modulok listája, és a modulok keresési útvonalainak listája.) Az \textit{eGhci} mező tartalmazza a háttérben futó GHCi példányra való hivatkozást. Az \textit{eCommand} és az \textit{eResult} valósítják meg a kommunikációt a kiértékelést végző szál és az alkalmazás fő szála között. Az \textit{eCommand}-nak a fő szál a termelője, és a kiértékelő szál a fogyasztója, az \textit{eResult}-nak pedig fordítva.

A \textit{gui} mező tartalmazza a GUI komponenseit. A pontos típusdefiníció a GUI leírásánál fog szerepelni.

A \textit{state} mező egy módosítható referencia, ami a számolótáblát reprezentáló, \textit{Spreadsheet} típusú adatot referálja. A file adattag tartalmazza az éppen a táblázatkezelőbe betöltött fájl fontosabb adatait, amennyiben be van töltve egy fájl. (Fájl neve, és állapota.)

Az \textit{EvalConfig} típus példánya \textit{Generic} és \textit{Serialize} típusosztályoknak. Erre a perzisztenciához van szükség.

\subsection{A GUI}

Az alábbi kódrészlet a GUI definíciója az \textit{App.Types} modulból:

\lstset{caption={A Gui típus}, label=src:gui}
\begin{lstlisting}[language={Haskell}]
data Menubar = Menubar { newButton :: Button
                       , saveButton :: Button
                       , loadButton :: Button
                       , modulesButton :: Button
                       , pathsButton :: Button
                       } deriving Eq

data Gui = Gui { mainWindow  :: Window
               , logWindow   :: ScrolledWindow
               , log         :: TextBuffer
               , table       :: Table
               , entryKeys   :: [(Entry,(Int,Int))]
               , editor      :: Entry
               , commandLine :: Entry
               , menu        :: Menubar
               } deriving Eq
\end{lstlisting}

A \textit{Gui} típus tartalmazza a Gui azon komponenseit, amelyekre szükség van a handlerek hozzáadásához. A \textit{mainWindow} komponens tartalmazza az alkalmazás főablakát. 

A számolótábla megjelenítése egy \textit{Table} segítségével történik. A cellákat a \textit{Table}-ben elhelyezett \textit{Entry}-k reprezentálják. Minden \textit{Entry}-hez egy \textit{(Int,Int)} kulcs is eltároltatik. Ez mutatja, hogy a tábla melyik pozíciójához tartozik az adott \textit{Entry}. Ez egy objektumorientált nyelvben megoldható lenne egy leszármazott widgettel (amelynek van egy extra mezője), azonban a \textit{gtk2hs} keretein belül ezt körülményes lett volna megoldani, így inkább ezt a megoldást választottam. Az \textit{Entry}-kulcs párokat az \textit{entryKeys} mező tartalmazza.

A grafikus felület alján található log egy \textit{ScrolledWindow}-ban elhelyezkedő \textit{TextView}. Magára a \textit{TextView}-ra nincs szükség, csak az általa használt \textit{TextBuffer}-re, ezért azt nem is tartalmazza a \textit{Gui}. Az editor és a parancssor egy-egy \textit{Entry}-vel vannak implementálva. A \textit{menu} komponens tartalmazza felső menüsoron elérhető gombokat. 

A GUI layout ennél alaposabb dokumentációja az \textit{App.CreateEnv} modul leírásában érhető el. 

\subsection{Programkomponensek és modulszerkezet (nem teljes!!!!!!!!!)}

Az alábbiakban röviden összefoglalom a szoftver moduljainak fő feladatát:

\begin{itemize}
	\item \textbf{Main} -- főprogram
	\item \textbf{App} -- az alkalmazás fő logikája, eseménykezelés
	\begin{itemize}
		\item \textbf{App.CreateEnv} -- a globális állapot inicializálása, GUI funkcionalitás nélkül
		\item \textbf{App.RunApp} -- a főprogram definiálása, a main loop terminálásakor végrehajtandó IO akciók megadása
		\item \textbf{App.Setup}	-- funkcionalitás hozzárendelése a GUI komponenseihez
		\begin{itemize}
			\item \textbf{App.Setup.CommandLine} -- a parancssor eseményeinek kezelése
			\item \textbf{App.Setup.Editor} -- a kódszerkesztő eseményeinek kezelése
			\item \textbf{App.Setup.Global} -- több GUI komponens által is használt akciók
			\item \textbf{App.Setup.Menubar} -- menüsor gombjaihoz tartozó események kezelése
			\item \textbf{App.Setup.Table} -- a számolótáblát megjelenítő táblázat eseményeinek kezelése
		\end{itemize}
		\item \textbf{App.Types} -- a globális állapothoz tartozó típusdefiníciók
	\end{itemize}
	\item \textbf{Eval} -- kifejezések GHCi-ban történő kiértékelése
	\begin{itemize}
		\item \textbf{Spreadsheet.CodeGeneration} -- kódgenerálás a kiértékeléshez (ezen modul dokumentációjában szerepel a kiértékelési modell leírása is)
		\item \textbf{Eval.EvalMain} -- a tényleges kiértékelést végző szál főprogramja
		\item \textbf{Eval.Ghci} -- az App számára biztosított interfész a kiértékeléshez
	\end{itemize}
	\item \textbf{Persistence} -- az App számára biztosított interfész fájlok mentéséhez és betöltéséhez
	\item \textbf{Spreadsheet} -- a számolótábla reprezentációja és műveletei
	\begin{itemize}
		\item \textbf{Spreadsheet.Interface} -- a számolótábla műveletei, amiket az App használhat
		\item \textbf{Spreadsheet.Parser} -- felhasználó által írt kód reprezentációjának előállítása
		\item \textbf{Spreadsheet.Types} -- a számolótábla és kapcsolódó kivételek típusdefiníciói
	\end{itemize}
\end{itemize} 

\section{A program komponenseinek részletes leírása}

\subsection{Spreadsheet.Types}

Az alkalmazás a Spreadsheet típussal reprezentálja a számolótábla állapotát. Alább látható a Spreadsheet.Types modulban szereplő definíció:

\lstset{caption={A Spreadsheet típus}, label=src:hs2}
\begin{lstlisting}[language={Haskell}]
type CellID = Int

data Cell' = Str String | Number Double | EmptyCell
  deriving (Eq, Show, Generic)

-- I need to come up with a better name lol
data ForPiece = Code String | Refs [CellID]
  deriving (Eq, Show, Generic)

data FormulaError = FNoParse
                  | FCycleRefError
                  | FNoCache
                  | FListTypeError
                  | FMissingDepError
                  | FGhciError
                  | FTimeoutError
  deriving (Eq, Show, Generic)

data Formula = Formula { _code :: String
                       , _cache :: Either FormulaError Cell'
                       , _value :: Maybe [ForPiece]
                       }
  deriving (Eq, Show, Generic)

data Cell = Val {_cellV :: Cell'} | For {_cellF :: Formula}
  deriving (Eq, Show, Generic)

data Spreadsheet = SS { _sheet :: Gr Cell Int
                      , _selected :: Maybe CellID
                      , _logMessage :: Maybe String
                      }
  deriving(Eq, Show, Generic)
\end{lstlisting}

A Spreadsheet egy rekord típus, amelynek három mezője van. A \textit{selected} mező jelenti az aktuálisan kijelölt cellát. Ez a mező kerülhetett volna a globális állapotba is, azonban a tervezés korai fázisában másképp döntöttem, és már nem feltétlenül éri meg refaktorálni a kódot. A \textit{\_logMessage} mező tartalmazza a legutóbbi művelet kiértékeléséből származó szöveges (a GUI-ban a logra írandó) üzenetet.

A \textit{\_sheet} mező reprezentálja a tényleges számolótáblát. A számolótábla egy irányított gráf, aminek a csúcsai \textit{Cell} típusú értékekkel vannak címkézve. Az élek egész számokkal vannak címkézve. (Lehetett volna \textit{()}-tal is, azonban a használt gráfcsomag által biztosított legrövidebb utak implementációnak szüksége volt számszerű élcímkékre. Az implementációban minden él címkéje \textit{1}.) A gráfban minden csúcs a számolótábla egy cellájának felel meg. Egy \textit{A} csúcsból pontosan akkor megy él egy \textit{B} csúcsba, ha a \textit{B} csúcsban található cella kódja hivatkozik az \textit{A} csúcsban található cellára. 

Egy cella pontosan akkor szerepel a gráfban, ha nemüres vagy van olyan cella, amelyik hivatkozik rá. Így az üres és nemhivatkozott cellák tárolására nincs szükség.

A fent megadott gráfreprezentációnak két további előnye is van. Egyrészt könnyű körfigyelést implementálni, így elkerülve, hogy cellák körkörösen hivatkozzanak egymásra; másrészt ha módosul egy \textit{A} cella tartalma, akkor pontosan az \textit{A}-ból elérhető csúcsoknak megfelelő cellákat kell újra kiértékelni.

A gráfreprezentáció megvalósításához az \textit{fgl} csomagot használtam. A műveletek a \textit{DynGraph} típusosztály tetszőleges megvalósítására működnek. \textbf{EZ MÉG NEM IGAZ, DE MAJD ÁTÍROM} A \textit{Spreadsheet} típus definíciójában a PatriciaTree alapú \textit{Gr} típust használtam.

Egy cella tartalmát a \textit{Cell} típus fejezi ki. Egy cella tartalma lehet érték (\textit{Cell'}) vagy formula (\textit{Formula}). Az érték jelenleg háromféle lehet: szám (\textit{Double}), string vagy üres.

Ha egy cella formulát tartalmaz, az a háromelemű \textit{Formula} rekorddal reprezentáltatik. A \textit{\_code} mező tartalmazza a felhasználó által megadott kódot. Ez egy kényelmi funkció, hogy a kód megjelenítéséhez ne kelljen visszakonvertálni a reprezentációból. A \textit{\_cache} mezőben szerepel, hogy mi a formula legutóbbi kiértékelésének eredménye (ha egyáltalán már ki lett értékelve). A cache értéke vagy egy érték (\textit{Cell'}) vagy valamilyen hiba (\textit{FormulaError}). 

A \textit{\_value} jelenti a formula kódgeneráláshoz szükséges reprezentációját.  Ez a reprezentáció \textit{ForPiece}-ek (formuladarabok) listája. Egy formuladarab vagy egy kódrészlet (\textit{String}) vagy cellaazonosítók listája. A \textit{\_value} mezőről részletesebben lesz szó a \textit{Spreadsheet.Parser} és a \textit{Spreadsheet.CodeGeneration} modulok leírásában. 

A \textit{Formula} típushoz tartozik egy invariáns állítás: a program futása során egy \textit{Formula} mindig a következő oldalon leírt állapotok valamelyikében figyelhető meg.

\begin{table}
	\centering
	\begin{tabularx}{\textwidth}{ |l l l l| X |}
		\hline
		\multicolumn{4}{|c|}{Minta} & \multicolumn{1}{|c|}{Jelentés} \\
		\hline\hline
		Formula & \_ & (Left FNoParse) & Nothing & parseolási hiba \\
		\hline
		Formula & \_ & (Left FCycleRefError) & Nothing & sikeres parseolás, azonban a formula körkörös referenciákat adott volna a táblához \\
		\hline
		Formula & \_ & (Left FNoCache) & (Just \_) & sikeres parseolás, érvényes referenciák, de a formula még nem lett kiértékelve \\
		\hline
		Formula & \_ & (Left FListTypeError) & (Just \_) & \textbf{ALMA?} \\
		\hline
		Formula & \_ & (Left FMissingDepError) & (Just \_) & a formula nem értékelhető ki, mivel egy hivatkozott cella nem volt cache-elve. \\
		\hline
		Formula & \_ & (Left FGHCIError) & (Just \_) & a formula egyéb okokból nem volt kiértékelhető (pl. típushiba, Haskell szintaxishiba) \\
		\hline
		Formula & \_ & (Left FTimeoutError) & (Just \_) & időtúllépés miatt sikertelen kiértékelés, valószínűleg végtelen ciklus miatt \\
		\hline
		Formula & \_ & (Right cell') & (Just \_) & sikeres kiértékelés, az eredmény cell' \\
		\hline 
	\end{tabularx}
	\caption[Egy \textit{Formula} lehetséges állapotai]{Egy \textit{Formula} lehetséges állapotai}
	\label{tab:formula}
\end{table}

Érdemes megjegyezni, hogy ez az invariáns típuszinten is garantálható lett volna (feladat az olvasó számára!). A jelenlegi megoldás a korai tervezési fázis eredménye, a későbbiekben már erőforrásigényes lett volna refaktorálni a kódot.   

További megjegyzések a \textit{Spreadsheet} típussal kapcsolatban:
\begin{itemize}
	\item A \textit{Spreadsheet.Types} modul alapértelmezett nevű lenseket is exportál a \textit{Cell, Formula} és \textit{Spreadsheet} típusokhoz.
	\item A \textit{Spreadsheet.Types} modulban szereplő összes típus (a kivételek kivételével) példánya a \textit{Generic} és \textit{Serialize} típusosztályoknak (ez utóbbit a \textit{cereal} csomag exportálja). Erre a perzisztencia implementációjához van szükség.
\end{itemize}

\subsection{Spreadsheet.Parser}

A modul feladata egy a felhasználó által egy cellához megadott kód (\textit{String}) reprezentációjának (\textit{Cell}) előállítása. A modul egy függvényt exportál. (\textit{rep :: String -> Cell)}

Legyen a felhasználó által megadott kód \textit{str}. A \textit{rep} függvény az alábbi specifikáció szerint állítja elő a kód cellareprezentációját.

\begin{compactenum}
	\item Ha str = "", rep str = \textit{Val EmptyCell}
	\item Ha str illeszkedik a $(+|-|\varepsilon)DD^*(.D^+|\varepsilon))$ reguláris kifejezésre, ahol D=(0|1|2|3|4|5|6|7|8|9), akkor rep str = \textit{Val (Num n)}, ahol \textit{n} a literál által ábrázolt lebegőpontos szám. 
	\item Ha a fenti esetek egyike sem áll fent, és str nem (=C*) alakú (ahol C az összes karakterek halmaza), akkor rep str = \textit{Val (Str str)}
	\item Ha B a betűk halmaza (a \textit{Data.Char} modul \textit{isLetter} függvényének igazsághalmaza), C' = $C \backslash \{\S\}$ és str $(=((\S  BD^+:BD^+\S )|(\S BD^+\S )|(C'^+))^+)$ alakú, akkor a kód formulaként parseolható. rep str = \textit{Formula str (Left FNoCache) (Just ps)}, ahol ps definíciója alább szerepel.
	\item Ha egyik fenti eset sem áll fent, akkor a parseolás sikertelen. Ekkor rep str = \textit{Formula str (Left FNoParse) Nothing}
\end{compactenum}

Ha \textit{str} formulaként parseolható (fenti 4. eset), egy egyszerű szintaktikus elemzés segítségével kaphatjuk a reprezentációjának \textit{\_value} komponensét. A parser először elhagyja az \textit{=} karaktert. Ezután sorban parseol substringeket a szó elejéről az alábbi módon:
\begin{compactenum}
	\item Először megpróbálja cellahivatkozásként olvasni a soron következő részt: $((\S  BD^*:BD^*\S )|(\S BD^+\S ))$. Ha sikerült, a hivatkozást cellaazonosítók sorozatává konvertálja (lásd alább), és a kapott \textit{rs} azonosítólistát $Refs\ rs$ módon az eredménylista végére fűzi.
	\item Ha a soron következő substring nem olvasható cellahivatkozásként, akkor a parser végigolvassa a lehető leghosszabb $s = C'^+$ substringet, és az eredménylistához egy $Code\ s$-t ír.
\end{compactenum}

A cellahivatkozások feloldásához kihasználjuk, hogy a karakterek injektíven az egész számok halmazára képezhetők (az \textit{Enum} típusosztály műveleteivel). A kis- és nagybetűket nem különbözetjük meg. Emellett definiálunk egy \textit{Enum} példányt \textit{(Int,Int)} párokra. \textbf{AZT IS LE KÉNE SZÉPEN ÍRNI...} Jelölje $fromEnum^C$ a karaktert Int-té kódoló függvényt, és $fromEnum^P$ az \textit{(Int,Int)} párt Int-té kódoló függvény. Jelölje $a,b :: Int$ esetén $[a..b]$ az $a \le n \le b$ n egész számok rendezett listáját! Ekkor a cellahivatkozások feloldása az alábbiak szerint történik:
\begin{compactenum}
	\item Ha a hivatkozás $(\S BD^*\S )$ alakú, legyen \textit{b} a betű, és \textit{n} a számjegyek által reprezentált egész szám. Ekkor a kapott  \textit{rs} lista egyelemű. $rs\ = [fromEnum^P\ (fromEnum^C,n)]$
	\item Ha a hivatkozás $(\S  BD^*:BD^*\S )$ alakú, felbontható a \textit{:} mentén két egyszerű hivatkozásra. Legyenek a betűk $d_1$ és $d_2$, a számjegyek által reprezentált számok pedig rendre $n_1$ és $n_2$! Ekkor XD LOL 
\end{compactenum}

\subsection{Spreadsheet.Interface}

Ebben a modulban szerepelnek az \textit{App} komponens számára elérhető, a \textit{Spreadsheet} típushoz kapcsolódó függvények. Alább látható táblázatos formában a modul által exportált függvények feladata:

\begin{table}
	\centering
	\begin{tabularx}{\textwidth}{ |l|X|X|}
		\hline
		Függvény & Típus & Feladat \\
		\hline\hline
		emptySpreadSheet & Spreadsheet & üres számolótábla (0 csúcsú gráf, nincs kijelölt cella, nincs log üzenet) \\
		\hline
		getCellText & CellID -> Spreadsheet -> String & egy cellában megjelenítendő szöveg lekérdezése \\
		\hline
		getCellCode & getCellCode :: CellID -> Spreadsheet -> String & egy adott cellába legutóbb beírt kód lekérdezése \\
		\hline
		setCellState & CellID -> String -> Spreadsheet -> Spreadsheet & a megadott cella állapotának módosítása egy a felhasználó által megadott String alapján \\
		\hline
		cacheCell & CellID -> Either EvalError String -> Spreadsheet -> Spreadsheet & kiértékelés eredményének cachelése \\
		\hline
		getSelected & Spreadsheet -> Maybe CellID & kijelölt cella azonosítója \\
		\hline
		setSelected & CellID -> Spreadsheet -> Spreadsheet & kijelölt cella azonosítójának beállítása \\
		\hline 
		getLogMessage & Spreadsheet -> String & legutóbbi log üzenet lekérdezése \\
		\hline
	\end{tabularx}
	\caption[A \textit{Spreadsheet.Interface} által exportált függvények]{A \textit{Spreadsheet.Interface} által exportált függvények}
	\label{tab:interface}
\end{table}

\subsubsection{setCellState}

A \textit{setCellState} függvény feladata, hogy a megadott cellaazonosítóhoz tartozó csúcsban lévő cella állapotát a felhasználó által megadott \textit{String}-nek megfelelően módosítsa, valamint felülírja a \textit{\_logMessage} mező tartalmát a múvelet sikerességétől függően.

Ehhez szükség van a megadott \textit{String} \textit{Cell} reprezentációjára, amit a \textit{Spreadsheet.Parser} modul által exportált \textit{rep} függvény számít ki. A kapott reprezentáció alapján az alább leírtaknak megfelelően viselkedik a függvény:

\begin{compactenum}
	\item Ellenőrzi, hogy a cella állapotának megváltoztatásával keletkeznék-e 		körkörös referencia. Pontosan akkor keletkeznék, ha a megváltoztatandó $c$ 	azonosítójú cellához tartozó csúcsba bemenő összes él kitörlésével keletkezett gráfban van olyan $n$ azonosítójú csúcs, hogy $c$ kódja hivatkozik $n$-re és a gráfban már van $c \rightarrow n$ út. (Ez utóbbi feltétel azt jelenti, hogy az $n$ cella értéke függ $c$ értékétől.) Ezt a feltételt az \textit{isLegal} függvény ellenőrzi. Érdemes megjegyezni, hogy ilyen hiba csak akkor fordulhat elő, ha a kapott reprezentációnk egy formula.
	\item Amennyiben az \textit{isLegal} eredménye \textit{False}, a $c$ csúcsban levő cella reprezentációja \textit{For (Formula str' (Left FCycleRefError) Nothing)} lesz, ahol \textit{str'} a paraméterként kapott \textit{String}. A \textit{\_logMessage} mezőbe egy hibaüzenet kerül.
	\item Amennyiben az \textit{isLegal} függvény \textit{True} eredményt ad, a gráfból kitöröltetik az összes $c$-be menő él, és új $c$-be menő élek kerülnek behúzásra a $c$ kódja által referált celláknak megfelelő csúcsokból. (Ezeket a \textit{references} függvény számolja a reprezentációból.) A \textit{\_logMessage} mező tartalma egy sikert jelző üzenet lesz.
\end{compactenum}

\textbf{ITT MÉG KÉNE ÍRNI TALÁN A FELHASZNÁLT SEGÉDFÜGGVÉNYEKRŐL?}

\subsubsection{cacheCell}

\subsection{Eval.CodeGeneration}

A kiértékelési folyamat az alábbi szempontok alapján került megtervezésre:
\begin{compactenum}
	\item Listán értelmezett függvények esetén legyen lehetőség könnyen kezelni az üres cellákat, alapértelmezett értékek megadásával.
	\item Ha a kiértékelés során hiba történik, annak a hatása minimális legyen.
\end{compactenum}

Az első szempont megvalósításához a kiértékelés során egy kiszámított vagy paraméterként kapott \textit{a} típusú értéket egy \textit{Maybe a} típusú érték reprezentálja. Az üres cellákat \textit{Nothing} reprezentálja, az értékkel rendelkező cellákat pedig egy \textit{Just} érték. Egy a kiértékelés során kiszámított cellaérték is mindig egy \textit{Just}-ba csomagoltatik. Ennek megfelelően \textit{a} típusú cellaértékek listájának futásidejű reprezentációja egy \textit{[Maybe a]}. A Haskellben megszokott listafüggvények a felhasználói dokumentációban részletesen leírt \textit{€} operátor segítségével használhatók ezen a reprezentáción.

A második szempont megvalósításához a kódgenerálás során értékadások sorozata jön létre, és a kiértékelés során ezen értékadások egyesével hajtódnak végre. Így ha valamelyik cella kiértékelésének eredménye egy hiba, csak a tőle függő cellák értéke lesz hiba. 

Ha sikeres a generálás, a \textit{generateCode} függvény eredménye két (egy \textit{Right} konstruktorba csomagolt) lista (\textit{[String],[(String,CellID)]}. Az első listába kerülnek az értékadások, amelyek az úgynevezett külső függőségekhez lettek generálva. A második lista tartalmazza az olyan értékadásokat, amelyek a megváltoztatott id-jű cellától függnek. A \textit{Spreadsheet.Types} modulnál tárgyalt gráfreprezentáció segítségével az előbbi két fogalmat az alábbi módon tehetjük precízzé: 

Legyen \textit{id} a megváltoztatott cella id-je, és legyen $lab : CellID \rightarrow Cell$ a gráf csúcsaihoz a megfelelő cellát hozzárendelő függvény! Legyenek $For,Lab : Cell \rightarrow \L$ predikátumok, amelyek akkor adnak igazat, ha a paraméterük a megfelelő konstruktorral jött létre. Legyen \textit{b} egy létező cellaazonosító! Ekkor:
\begin{align*}
	\text{b külső függőség} &\Leftrightarrow \exists c: (\exists (id \rightarrow c \text{ út}) \wedge \exists (b \rightarrow c \text{ út}) \wedge \not\exists  (id \rightarrow b \text{ út})) \\
	& \vee((b=id) \wedge Val(lab(b))) \\
	\text{b függ id-től} &\Leftrightarrow ((b \not= id) \wedge \exists (id \rightarrow b \text{ út}) \\
	&\vee ((b = id) \wedge For(lab(b)))
\end{align*}

A külső függőségeket olyan módon kell sorrendbe rendezni, hogy az eredménylistában egy cella csak az őt megelőző külső függőségektől függjön. Ekkor az értékadásokat lehetséges a lista által megadott sorrendben végrehajtani. A sorba rendezéshez a leghosszabb utak algoritmusa szerinti szintek használatosak, ezek alapján kerülnek növekvő sorrendbe a külső függőségek. Könnyű látni, hogy ez a sorrend megfelel a fent megfogalmazott elvárásnak.  

A kódgeneráláshoz szükséges ellenőrizni, hogy a kapott külső függőségek értéke kiolvasható-e. Ez akkor lehetséges, ha a külső függőség egy \textit{Val}, vagy egy olyan \textit{For}, amelybe van cachelve érték.

Az \textit{id}-től függő cellák esetén (ezek szükségszerűen formulák) azt kell ellenőrizni, hogy sikerült-e parseolni. Ez ekvivalens azzal, hogy a \textit{\_value} mező értéke \textit{Just}.

A függőségek listáinak kiszámítása és a fenti ellenőrzések elvégzése a \textit{depList} függvény feladata. A leghosszabb utak szerinti szinteket kiszámító függvény a \textit{GraphFunctions} modulban szerepel. 

Az értékadások generálásáért a \textit{codeG} függvény felel. Ez az \textit{n} azonosító cellához egy \textit{vn = someCode} formájú értékadást generál. A \textit{someCode} részt külső függőség esetén a \textit{cacheG}, \textit{id}-től függő cella esetén a \textit{cellG} függvény számítja ki.

A \textit{cacheG} függvény üres cellákhoz a \textit{"Nothing"} stringet rendeli. Számokhoz és stringekhez pedig egy \textit{"Just val"} stringet, ahol \textit{val} a megfelelő szám/string. Amennyiben egész számról van szó, a függvény levágja a tizedesrészt a számliterálról, hogy a GHCi egész típusúként értelmezhesse a literált.

A \textit{cellG} függvény a formula \textit{\_value} komponensének elemeiből egy stringet állít elő. Ehhez a \textit{\_value} mező minden eleméhez egy stringet rendel, és ezeket konkatenálja, majd a legvégén eléír egy \textit{"Just \$ "}-t. A függvény az egyes elemekhez az alábbi módon rendel stringeket:
\begin{compactenum}
	\item \textit{Code code} $\rightarrow$ code
	\item \textit{Refs [n]} $\rightarrow$ "fromJust v\textit{n}"
	\item \textit{Refs ids}, ha $|ids| > 1 \ \rightarrow$ az ids-ben szereplő cellaazonosítókból generált változónevek listája. Pl. ids=\textit{[1,2,3]} esetén \textit{"[v1,v2,v3]"}
\end{compactenum}

A fenti leírásból jól látszik, hogy egy cella értéke mindig \textit{Just}-ba lesz csomagolva. Ha egy cella értékét akarjuk használni, az a "szokásos módon" megtehető, mivel a változónév elé egy \textit{fromJust} kerül. Cellák listája esetén azonban \textit{Just} értékek listáját kapjuk. Ez esetben tehát a szokásos Haskell függvények nem a megszokott módon működnek, de az \textit{€} operátor segítségével ez könnyen áthidalható. Érdemes megjegyezni, hogy a cellákhoz kiszámított érték mindig \textit{Maybe a} típusú lesz, így az eredmény kinyeréséhez a \textit{fromJust vn} kód szükséges. Ha az eredmény \textit{Nothing}, ez futásidejű hibát okoz, amit a hívó ki tud olvasni a GHCi-ból, és cachelhet egy hibát a kiértékelt cellához (\textit{EGhciError}).

A modul által exportált \textit{generateCode} függvény segítségével végezhető el a fent leírt kódgenerálás. 

\subsection{Eval.EvalMain}

A modul által exportált \textit{evalMain} függvény biztosítja a kifejezések GHCi-ben való kiértékelését végző szál főprogramját. A szál az alábbiak szerint működik:

\begin{compactenum}
	\item Várakozik, ameddig a globális állapot \textit{evalControl} mezőjének \textit{eCommand} változójába egy GHCi utasítást nem ír a fő szál.
	\item Kiüríti a változót, és kiértékeli a kapott utasítást a GHCi-ben.
	\item Ha egy megadott idő után nem ér véget a kiértékelés (jelenleg 1 másodperc), lekérdezi a GHCi folyamathoz tartozó PID-et, majd megkeresi annak a gyerekfolyamatát (\textit{childPid}), és az \textit{eResult} változóba \textit{Left\ childPid}-et ír. Ezt a folyamatot aztán a fő szál fogja kilőni.
	\item Amennyiben időben véget ér a kiértékelés, a GHCi által eredményül adott sorok \textit{result} listáját \textit{Right\ result} módon az \textit{eResult} változóba írja.
\end{compactenum}

A timeout utáni viselkedés bonyolultsága egy szerencsétlen helyzet eredménye. A magyarázathoz meg kell ismerni a \textit{ghcid} csomag által biztosított GHCi interfészt. A \textit{startGhci} függvény a dokumentáció alapján elindít egy GHCi háttérfolyamatot, amellyel innentől egy megadott szálról kell interaktálni (a megszakítást kivéve). A valóságban azonban azt tapasztaltam, hogy két folyamatot indít el, amelyek közül az egyik gyereke a másiknak. 

Időtúllépés esetén meg kell állítani a háttérben futó számítást. Erre szolgálna az \textit{interrupt} függvény, ami egy \textit{SIGINT} jelzést küld a GHCi folyamatnak. A GHCi folyamat azonban bizonyos esetekben ezt kimaszkolja, ilyenkor a számítást nem lehetséges megszakítani. \textbf{IDE KÉNE LINK ERRŐL A DISKURZUSRÓL} A GHCi leállítására szolgáló \textit{stopGhci} függvény pedig csak  az egyik (a szülő) folyamatot terminálja a \textit{startGhci} által indított két folyamatból. A másik folyamat pedig tovább folytatja a számítást. Az alkalmazás egy Haskell szálat tartalmazó verziójában ez kiéheztette az fő folyamatot. 

Ezért van szükség arra, hogy a kiértékelés külön szálon fusson. Ugyanis időtúllépés esetén a fő szál, miután ütemezésre kerül, a kapott PID alapján a lehető legagresszívabban (\textit{SIGKILL}) terminálja a második GHCi folyamatot. Ez a tapasztalat szerint az első folyamatnak is véget vet. Ezután új GHCi folyamat indítható.

A fenti megoldást a szükség szülte, és tapasztalatok alapján, gyakran próbálgatás útján állt össze. Nem ismert, hogy miért indít a \textit{startGhci} két folyamatot. (Egy "rendes" GHCi folyamathoz például csak egy PID tartozik.) A megoldás az én számítógépemen, Ubuntu 20.04 LTS operációs rendszer mellett működött, de nincs rá garancia, hogy más Linux rendszer (vagy akár egy másik számítógép!) esetén működni fog. (A működés feltétele, hogy ütemezésre kerüljön a fő szál.) Ráadásul csak e miatt az interakció miatt kellett konkurrenciát adni az alkalmazáshoz. Valódi hatékonyságot ezzel nem nyertünk, hiszen az egyik szál mindig blokkolt állapotban lesz. (Mivel mindkét szál a fogyasztóként hozzá tartozó \textit{MVar}-ra várakozik, ha éppen a másik szál dolgozik.)

A gyerekfolyamat megtalálásához a program rendszerhívást hajt végre, a \textit{pgrep} parancsot használja \textit{-P} kapcsolóval.

\subsection{Eval.Ghci}

A modul fő feladata, hogy kiértékeljen egy GHCi parancsot, és az eredményt értelmezze. Emellett lehetőséget biztosít a modulok és keresési útvonalak újratöltésére a globális konfiguráció alapján (\textit{EvalConfig}).

\begin{table}
	\centering
	\begin{tabularx}{\textwidth}{ |X|X|}
		\hline
		Függvény & Típus \\
		\hline\hline
		execGhciCommand & String -> ReaderT EvalControl IO (Either EvalError String) \\
		\hline
		loadModules & ReaderT EvalControl IO () \\
		\hline
	\end{tabularx}
	\caption[Az \textit{Eval.Ghci} által exportált függvények]{Az \textit{Eval.Ghci} által exportált függvények}
	\label{tab:interface}
\end{table}

A kiértékelés folyamata a (nem exportált) \textit{execG} függvényben van leírva, és az alábbi módon zajlik:
\begin{compactenum}
	\item A paraméterként kapott parancs a \textit{eCommand} változóba kerül.
	\item Kiolvasásra kerül az eredmény az \textit{eResult} változóból.
	\item Ha az eredmény \textit{Left\ pid}, a kapott PID-hez tartozó folyamat terminálásra kerül, és a kiértékelés eredménye \textit{Left\ ETimeoutError}. Új GHCi folyamat indul, és a hivatkozása bekerül a globális állapot \textit{evalConfig} mezőjének \textit{eGhci} mezőjébe.
	\item Ha az eredmény \textit{Right\ result}, ez a kiértékelés eredménye. \textit{result :: [String]} a GHCi által eredményül adott sorok listája.
\end{compactenum}

Az exportált \textit{execGhciCommand} függvény ezt a viselkedést egészíti ki egy extra ellenőrzéssel.
\begin{compactenum}
	\item Ha az \textit{execG} eredménye \textit{Left\ ETimeoutError}, akkor ez az eredmény.
	\item Ha az \textit{execG} eredménye \textit{Right\ results}:
	\begin{itemize}
		\item Ha \textit{results} üres, az eredmény \textit{Right\ ""}
		\item Ha \textit{results} egyelemű, az eredmény \textit{Right\ (head (results))}
		\item Ha \textit{results} több elemű, akkor a GHCi több sornyi eredményt adott vissza. Ezt a függvény hibának tekinti, és az eredmény \textit{Left (EGhciError results)}
	\end{itemize}
\end{compactenum}

A \textit{loadModules} akció beállítja a globális állapot \textit{evalControl} mezőjének \textit{eConfig} mezője alapján az elérési utakat, majd betölti a megadott modulokat. A korábban betöltött modulokat először kitölti (\textit{:m}). Ilyenkor a felhasználó által közvetlenül a GHCi-ba megadott definíciók is elvesznek. Az akció betölti az \textit{Empty} modult is, ami szükséges ahhoz, hogy működjék az \textit{€} minta, amit a cellablokkok kezeléséhez biztosít a program.

\subsection{Persistence}

A modul feladata, hogy fájlokat mentsen és betöltsön. Egy adatot akkor lehet elmenteni, ha az adat típusa példánya a \textit{Serialize} típusosztálynak. Ezt a típusosztályt a \textit{cereal} csomag biztosítja. Egy \textit{Serialize} példány minden eleme bytestring-gé szerializálható. A program a számolótáblák és a konfigurációs fájlok perzisztálásához is bytestring formátumot használ.

Jelenleg a program egy konfigurációs fájlt használ, ennek nevét a \textit{moduleConfigFile} konstans definiálja. Az alkalmazás bezárásakor ebbe a fájlba kerül mentésre a globális állapot \textit{evalControl} mezőjének \textit{eConfig} mezője.

\subsubsection{saveSheet :: Serialize a => String -> a -> IO ()}

Ez a függvény elment egy szerializálható adatot a megadott fájlnévvel. Létező fájl esetén felülírás történik. 

\subsubsection{loadSheet :: Serialize a => String -> IO (Either String a)}

Betölti a paraméterként kapott fájlból az adatot. Ha nem létezik a fájl, az eredmény egy hibaüzenet, ami jelzi, hogy a paraméterként kapott fájl nem létezik.

\subsubsection{saveModuleConfig :: EvalConfig -> IO ()}

A \textit{saveSheet} speciális esete. A kapott paramétert a \textit{moduleConfigFile} konstans által megadott fájlba menti.

\subsubsection{loadModuleConfig :: IO EvalConfig}

Betölti a modulkonfigurációs fájl tartalmát. Ha a fájl nem létezik, az IO akció üres konfigurációt eredményez: (\textit{EvalConfig [] []}).

\subsection{App.RunApp}

Ez a modul definiálja a főprogramot (\textit{appMain :: IO () )}, amellyel egyenlő a \textit{Main}-ben definiált \textit{main} függvény. Az \textit{appMain} két akcióból áll. Először inicializálja a globális állapotot (\textit{App.CreateEnv.createEnv}), majd végrehajtja a \mbox{\textit{runApp :: ReaderT Env IO ()}} akciót, a globális állapotot az inicializált környezetre állítva. A 
\textit{createEnv} akció elindítja a háttérben futó kiértekelő szálat is. (\textit{Eval.EvalMain.evalMain}).

A \textit{runApp} akció a következőképpen határozza meg a program működését:
\begin{compactenum}
	\item Hozzárendeli a GUI elemeihez a handlereket (\textit{App.Setup.setupGui})
	\item Betölti a betöltendő keresési útvonalakat és modulokat a GHCi-be (\textit{Eval.Ghci.loadModules}).
	\item Beállítja, hogy az alkalmazás bezárásakor álljon le a GHCi és a modulok konfigurációja kerüljön mentésre.
	\item Megjeleníti a GUI-t és elindítja a main loopot. 
\end{compactenum}

\subsection{App.CreateEnv}

Ez a modul exportálja az \textit{App.RunApp}-ban használt \mbox{\textit{createEnv :: IO Env}} akciót.

A \textit{createEvalControl :: IO EvalControl} segédakció hozza létre az \textit{evalControl} mező tartalmát. Az \textit{eGhci} mezőhöz elindít egy GHCi-t. A GHCi alapértelmezett munkakönyvtára az alkalmazás futtatásának helye. Az \textit{eCommand} és \textit{eResult} mezőkhöz létrehoz egy-egy üres \textit{MVar}-t. Az \textit{eConfig} mező tartalmát beolvassa a konfigurációs fájlból (\textit{Persistence.loadModuleConfig}).

A state mező az üres számolótáblával kerül inicializálásra (\textit{Spreadsheet.Interface.emptySpreadSheet}). A file mező \textit{Nothing}-gal kerül inicializálásra, mivel kezdetben nincs betöltve fájl az alkalmazásba

A \textit{createGui :: IO Gui} segédakció építi fel a GUI-t. Az alkalmazás grafikus felületét egy \textit{Window} tartalmazza (\textit{mainWindow}). Ennek az ablaknak a gyereke egy \textit{VBox}, amely a további widgeteket tartalmazza.   Ezek rendre a menüsor (egy \textit{HBox}, ami \textit{Button}-öket tartalmaz),  az egysoros kódszerkesztő (\textit{Entry}), a cellákat tartalmazó táblázat (\textit{Table}), a logot megjelenítő \textit{ScrolledWindow} és a parancssornak megfelelő \textit{Entry}.

A \textit{Table} létrehozásakor jönnek létre a cellák megjelenítésére szolgáló \textit{Entry}-k, melyek a pozíciójukat leíró kulccsal együtt kerülnek mentésre.

A menüsor gombjaihoz itt kerülnek hozzárendelésre a billentyűkombinációk.

Az akció "*new file"-ra állítja a fő ablak címét, mivel az alkalmazás elindításakor nincs betöltött fájl.

\subsection{App.Setup}

Ez a modul exportálja a \textit{setupGui} akciót, amelynek feladata, hogy a GUI-hoz eseménykezelőket rendeljen. Ezek az eseménykezelők definiálják az alkalmazás lényegi működését. A \textit{setupGui} akció rendre végrehajtja a \textit{setupEditor}, \textit{setupCommandLine}, \textit{setupMenubar} és \textit{setupTable} akciókat, amelyek definiálják az egyes GUI komponensek működését. Ezek az akciók a megfelelő nevű \textit{App.Setup.*} almodulban vannak definiálva.

Az eseménykezelők megadásához egy \textit{IO ()} akcióra vagy egy \mbox{\textit{Event-> IO ()}} függvényre van szükség. Ez azért hátrányos, mert nem lehetséges az eseménykezelőket közvetlenül a ReaderT kontextusban definiálni. Ezért az eseménykezelők megadására az alábbi minta használatos:

\lstset{caption={Az eseménykezelők hozzárendelése}, label=src:ehandler}
\begin{lstlisting}[language={Haskell}]
setupSomeWidget :: ReaderT Env IO ()
setupSomeWidget = do
	widget <- ...
	env <- ask
	...
	void $ lift $ onSomeEvent widget $ runReaderT handlerAction env
	
handlerAction :: ReaderT Env IO ()
\end{lstlisting}

Tehát a eseménykezelőt hozzárendelő függvény lekérdezi a globális állapotot, és a handler nem más, mint egy ReaderT IO akció futtatása a globális állapottal. Így viszonylag kényelmesen használható a globális állapot a handlerek megírásakor. A fent leírt minta akkor is alkalmazható, ha van egy extra \textit{Event} paraméter (pl. \textit{onFocusOut}).  Ilyenkor a \textit{handlerAction}-nek paraméterként adható az \textit{Event}.

\subsection{App.Setup.Global}

Ez a modul olyan akciókat definiál, melyeket az \textit{App.Setup} további almoduljai felhasználhatnak. Az alább leírtak mellett a modul exportál néhány, a globális állapot egyes komponenseinek lekérdezését kényelmesebbé tevő akciót is.

\subsubsection{setTitle :: String -> ReaderT Env IO ()}

A fő ablak címét a megadott \textit{String}-re állítja.

\subsubsection{logAppendText :: String -> ReaderT Env IO ()}

A paraméterként kapott \textit{String}-et új sorként hozzáadja a log aljához, majd legörget a logot tartalmazó \textit{ScrolledWindow}-ban. A legörgetés többsoros üzenet esetén csak az első sorig görget le. Ez egy ismert hiba, amit egyelőre nem sikerült javítani. Jelenleg nincs számontartva a log mérete, és nincs is maximális mérete. Ennek értelmében a logüzeneteket tartalmazó buffer mérete tetszőlegesen nagy lehet. \textbf{EZT FULL KI KÉNE JAVÍTANI AM XC}

\subsubsection{updateView :: ReaderT Env IO ()}

A globális állapot \textit{state} mezője alapján frissíti a cellákban megjelenő szöveget. Ehhez felhasználja a \textit{Spreadsheet.Interface.getCellText} függvényt.

\subsubsection{evalAndSet :: CellID -> ReaderT Env IO}

Kiértékeli a megadott azonosítójú cellához generált kódrészleteket, majd a kiértékelés eredményét cacheli a számolótáblába. A betöltött fájl állapotát \textit{Modified}-ra módosítja.

A kiértékeléshez először kódot generál a kapott azonosítóhoz \mbox{(\textit{Spreadsheet.CodeGeneration.generateCode})}. Kódgenerálási hiba esetén logolja a hibát jelző üzenetet. 

Ha sikeres volt a kódgenerálás, akkor a kapott sorrendben kiértékeli az utasításokat a GHCi-ben. Ehhez először törli a korábbi GHCi bindingokat az \textit{Eval.Ghci.loadModules} akcióval. Erre azért van szükség, hogy ha egy cellához rendelt változót nem sikerült kiszámítani (pl. típushiba miatt), akkor a leszármazott cellához ne legyen felhasználható egy korábbi kiértékeléskor kiszámított, elavult érték. Ezután kiértékeli a külső dependenciákat, azaz azon cellákat, amelyek nem függnek a megváltoztatott cellától, de függőségei valamely  a megváltoztatott cellától függő cellának. (Ez a kódgenerálás által adott első lista.)

Ezután következik a második lista utasításainak kiértékelése. Minden utasítás esetén először kiértékeli az "értékadást". Ha az eredmény hiba, a kiértékelés eredménye hiba. Ha az eredmény nem hiba, akkor lekérdezi a kiértékelt változót. A kódgenerálás garanciát ad arra, hogy egy cella mindig a függőségei után kerül kiértékelésre.

Az összegyűjtött eredmények ezután cacheltetnek \mbox{(\textit{Spreadsheet.Interface.cacheCell})}. A betöltött fájl állapota \textit{Modified} lesz.

\subsubsection{updateView :: ReaderT Env IO}

A számolótábla állapota alapján frissíti a cellákban megjelenített szöveget. Ehhez felhasználja a \textit{Spreadsheet.Interface.getCellText} függvényt. A cellatartalmak lekérdezése a GUI \textit{entryKeys} komponensében tárolt kulcsok alapján történik.

\subsection{App.Setup.CommandLine}

A modul a parancssor (\textit{Entry}) \textit{onEntryActivate} eseményéhez (enter billentyű leütése) rendel eseménykezelőt. Az esemény hatására bekövetkező viselkedés a következő:
\begin{compactenum}
	\item A parancssorban lévő szöveg parancsként parseoltatik.
	\item Ha GHCi parancsként értelmezhető (a parseolás eredménye \textit{ClGhci cmd}), akkor végrehajtatik a GHCi parancs, és az eredmény logolásra kerül.
	\item Ismeretlen parancs esetén logolásra kerül a hiba.
	\item A parancsorból eltűnik a szöveg.
\end{compactenum}

\subsection{App.Setup.Editor}

A modul a kódszerkesztő (\textit{Entry}) \textit{onFocusOut} (fókusz elvesztése), \textit{onFocusIn} (fókusz megszerzése) és \textit{onEntryActivate} eseményeihez rendel eseménykezelőt.

A fókusz elvesztésekor és az enter leütésekor az alábbi viselkedés következik be:
\begin{compactenum}
	\item Amennyiben nem volt kiválasztva cella a táblában, nem történik semmi.
	\item Amennyiben volt kiválasztott cella, a cella állapota módosításra kerül a bevitt szöveg alapján (\mbox{\textit{Spreadsheet.Interface.setCellState)}}. Ha ezzel megváltozott a cella állapota, végrehajtódik egy kiértékelés, aminek a gyökere a megváltoztatott cella. (\mbox{\textit{App.Setup.Global.evalAndSet}}).
	\item Frissül a táblanézet ((\mbox{\textit{App.Setup.Global.updateView)}}
\end{compactenum}

A fókusz megszerzésekor amennyiben volt kijelölt cella, úgy annak a legutóbb megadott kódja jelenik meg a szerkesztőben.

\subsection{App.Setup.Menubar}

A modul eseménykezelőket rendel a menüsor gombjainak (\textit{Button}) \textit{onClicked} eseményéhez.

\subsubsection{runAreYouSureDialog :: IO Bool}

Ez a segédakció egy felugró ablak segítségével visszaad egy igen-nem választ ("biztos-e ebben" dialógus). Több handler is használja, amikor fennálna a lehetőség, hogy a végrahajtandó akció végrehajtása során elvesznének nem mentett információk.

\subsubsection{getFileChooserDialog :: FileChooserAction -> IO FileChooserDialog}

Ez a segédakció hozza létre a mentéshez és betöltéshez szükséges dialógusokat. A kapott paramétertől függ, hogy mentéshez vagy betöltéshez szükséges dialógus jön létre.

\subsubsection{newAction :: ReaderT Env IO () -- USERBE MEGY}

A "New" gomb megnyomásakor az alábbiak történnek:
\begin{compactenum}
	\item Felugrik a "biztos-e ebben" dialógus.
	\item Nemleges válasz esetén nem történik semmi.
	\item Igenlő válasz esetén a globális állapot \textit{state} mezőjébe egy üres számolótábla kerül. A \textit{file} mező értéke \textit{Nothing} lesz. Az ablak címe "*new file" lesz.
	\item Frissül a nézet
\end{compactenum}

\subsubsection{loadAction :: ReaderT Env IO () -- USERBE MEGY}

A "Load" gomb megnyomásakor az alábbiak történnek:
\begin{compactenum}
	\item Megjelenik a betöltéshez szolgáló fájlválasztó dialógus.
	\item Amennyiben a felhasználó a "Load" gombra kattintott, és megadott egy fájlnevet.
\end{compactenum}

\subsection{App.Setup.Table}

A modul eseménykezelőket rendel a cellák megjelenítésére szolgáló \textit{Entry}-k \textit{onFocusIn} és \textit{onFocusOut} eseményeihez.

\section{Tesztelés}

LOL XD HAHA TESZTEK OMEGALUL XC