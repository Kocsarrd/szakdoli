\chapter{Fejlesztői dokumentáció} % Developer guide
\label{ch:impl}

\section{A fejlesztői dokumentáció felépítése}

A fejlesztői dokumentáció három nagy részből áll. Az 3.2 részben ismertetésre kerülnek a szoftver készítése során felhasznált technológiák, valamint nagy vonalakban a szoftver logikai felépítése. (Milyen programkomponensek vannak, milyen feladatokat látnak el, hogyan kapcsolódnak egymáshoz.) A 3.3 rész tartalmazza az egyes komponensek részletesebb leírását. Minden komponens esetén ismertetésre kerül a más komponensek felé nyilvánosságra hozott interfész, valamint a komponensek működési elve, beleértve a használt típusok leírását és a fontosabb algoritmusok működési elvét. A 3.4 rész tartalmazza a tesztelési eljárás leírását és a tesztelés eredményeit. 

\section{A szoftver felépítése}

\subsection{Felhasznált technológiák összefoglalása}

Az alkalmazás Haskell nyelven íródott. A grafikus megjelenítés \textit{GTK+} alapú, a \textit{gtk2hs} csomag által biztosított bindingokat használtam a grafikus felület kezeléséhez. Ez a csomag a \textit{GTK+} osztályhierarchiáját Haskell típusosztályok hierarchiájaként adja vissza. Az egyes osztályok metódusainak a típusosztályok definíciójában szereplő függvények felelnek meg. A \textit{GTK+} típusai foreign pointerek segítségével vannak megvalósítva, és \textit{IO}-ban használhatók. 

Az alkalmazás a \textit{GTK+} logikájának megfelelően eseményvezérelt. A felhasználó akciói eseményeket váltanak ki, amelyek hatására handlerek futnak le. A handlerek minden esetben \textit{IO} akciók, amelyek valamilyen módon módosítják a globális állapotot (lásd 3.2.1. Globális állapot). A szoftver fejlesztése során fontos volt, hogy minél kevesebb legyen az tisztátalan (impure), \textit{IO}-n belül elvégzett számítás. Igyekeztem a program logikájának minél nagyobb részét egy tiszta, nem monadikus környezetben megvalósítani. Így a számítások helyessége könnyebben tesztelhető/verifikálható, a handlerek már keveset számolnak az \textit{IO}-ban.

Az alkalmazás a parseolási feladatokhoz a \textit{parsec} csomagot, a gráfok kezeléséhez az \textit{fgl} csomagot, a ghci futtatásához pedig a \textit{ghcid} csomagot használja. A modell adatainak könnyebb kezeléséhez a \textit{microlens-platform} csomagot használtam, ami a jól ismert \textit{lens} csomag egy kevesebb funkciót és kevesebb függőséget tartalmazó változata. A függőségek pontos listája elérhető a Felhasználói dokumentációban, illetve az egyes programkomponensek részletes leírásakor is említésre kerülnek a fontosabb felhasznált csomagok.

\subsection{A globális állapot}

Az alkalmazás fő felépítését egy az FP Complete blogján megjelent cikk \textbf{(IDE KÉNE EGY REFERENCIA)} inspirálta. 
Az alkalmazás a globális (olvasható) állapotot a \textit{ReaderT} monád transzformer segítségével valósítja meg, az alkalmazás vezérlése így egy \textit{ReaderT Env IO} környezetben történik, ahol \textit{Env} a globális állapotot leíró adattípus. Fontos megjegyezni, hogy bár az \textit{Env} típus komponensei az inicializálás után sosem módosulhatnak, a mögöttes állapot még változhat, hiszen a komponensek módosítható referenciák. Ez nagyon hasonló a Java nyelvben használható konstans referencia koncepciójához: a referencia nem változhat, de a referált adat igen.

A fentebb referált cikk által inspirálva a (GUI komponensein kívüli) globális állapot egy \textit{StateT} transzformer helyett módosítható referenciákkal (\textit{IORef} és \textit{MVar}) kezeltetik. Ugyanis hiába tiszta, ha globálisan használjuk a \textit{StateT}-t, valójában -- a programlogika szintjén -- ugyanúgy egy globális, módosítható állapotot vezetünk be. Szintén egy szempont, hogy a \textit{GTK+} alapú \textit{GUI} miatt eleve szerepelnek módosítható referenciák (foreign pointer) a globális állapotban, így ez a probléma semmiképpen nem kerülhető el teljesen. Egy további érv a globális \textit{StateT} ellen, hogy egy nagyobb monad stack szükségszerűen bonyolítja a programot. A \textit{ReaderT IO} ellenben még kifejezetten könnyen kezelhető. A cikk konkurrenciához köthető problémákat is említ a \textit{StateT}-vel kapcsolatban. Ez a szoftver jelenlegi verziójában még nem olyan jelentős (lévén a mostani implementáció nagyon kis mértékben épít konkurrenciára). Azonban a jövőre nézve mindenképpen előnyös, ha a szoftvert könnyen lehet a konkurrens paradigma szerint bővíteni.

Ezen bevezető után tekintsük a globális állapot definícióját! Az alábbi típusdefiníció az \textit{App.Types} modulban található:
\lstset{caption={Az Env típus}, label=src:hs}
\begin{lstlisting}[language={Haskell}]
data EvalConfig = EvalConfig { modules :: [String]
                             , paths :: [String]
                             }
  deriving (Eq, Generic)

data EvalControl = EvalControl { eGhci    :: MVar Ghci
                               , eCommand :: MVar String
                               , eResult  :: MVar (Either String [String])
                               , eConfig  :: MVar EvalConfig 
                               } deriving Eq

data SaveStatus = Saved | Modified
  deriving Eq

data File = File FilePath SaveStatus
  deriving Eq
  
data Env = Env { evalControl  :: EvalControl
               , gui          :: Gui
               , state        :: IORef Spreadsheet
               , file         :: IORef (Maybe File)
               } deriving Eq
\end{lstlisting}

Az \textit{evalControl} mező tartalmazza a kifejezések ghci-ban való kiértékelés hez szükséges erőforrásokat. Az \textit{eConfig} mező tartalmazza a GHCi-hoz tartozó konfigurációs beállításokat. (Betöltött modulok listája, és a modulok keresési útvonalainak listája.) Az \textit{eGhci} mező tartalmazza a háttérben futó GHCi példányra való hivatkozást. Az \textit{eCommand} és az \textit{eResult} valósítják meg a kommunikációt a kiértékelést végző szál és az alkalmazás fő szála között. Az \textit{eCommand}-nak a fő szál a termelője, és a kiértékelő szál a fogyasztója, az \textit{eResult}-nak pedig fordítva.

A \textit{gui} mező tartalmazza a GUI komponenseit. A pontos típusdefiníció a GUI leírásánál fog szerepelni.

A \textit{state} mező egy módosítható referencia, ami a számolótáblát reprezentáló, \textit{Spreadsheet} típusú adatot referálja. A file adattag tartalmazza az éppen a táblázatkezelőbe betöltött fájl fontosabb adatait, amennyiben be van töltve egy fájl. (Fájl neve, és állapota.)

Az \textit{EvalConfig} típus példánya \textit{Generic} és \textit{Serialize} típusosztályoknak. Erre a perzisztenciához van szükség.

\subsection{Programkomponensek és modulszerkezet (nem teljes!!!!!!!!!)}

Az alábbiakban röviden összefoglalom a szoftver moduljainak fő feladatát:

\begin{itemize}
	\item \textbf{Main} -- főprogram
	\item \textbf{App} -- az alkalmazás fő logikája, eseménykezelés
	\begin{itemize}
		\item \textbf{App.CreateEnv} -- a globális állapot inicializálása, GUI funkcionalitás nélkül
		\item \textbf{App.RunApp} -- a főprogram definiálása, a main loop terminálásakor végrehajtandó IO akciók megadása
		\item \textbf{App.Setup}	-- funkcionalitás hozzárendelése a GUI-hoz
		\item \textbf{App.Types} -- a globális állapothoz tartozó típusdefiníciók
	\end{itemize}
	\item \textbf{Eval} -- kifejezések GHCi-ban történő kiértékelése
	\begin{itemize}
		\item \textbf{Eval.EvalMain} -- a tényleges kiértékelést végző szál főprogramja
		\item \textbf{Eval.Ghci} -- az App számára biztosított interfész a kiértékeléshez
	\end{itemize}
	\item \textbf{Persistence} -- az App számára biztosított interfész fájlok mentéséhez és betöltéséhez
	\item \textbf{Spreadsheet} -- a számolótábla reprezentációja és műveletei
	\begin{itemize}
		\item \textbf{Spreadsheet.CodeGeneration} -- kódgenerálás a kiértékeléshez, \textbf{FULL NEM ITT KÉNE LENNIE 44!4!!4}
		\item \textbf{Spreadsheet.Interface} -- a számolótábla műveletei, amiket az App használhat
		\item \textbf{Spreadsheet.Parser} -- felhasználó által írt kód reprezentációjának előállítása
		\item \textbf{Spreadsheet.Types} -- a számolótábla és kapcsolódó kivételek típusdefiníciói
	\end{itemize}
\end{itemize} 

\section{A program komponenseinek részletes leírása}

\subsection{Spreadsheet.Types}

Az alkalmazás a Spreadsheet típussal reprezentálja a számolótábla állapotát. Alább látható a Spreadsheet.Types modulban szereplő definíció:

\lstset{caption={A Spreadsheet típus}, label=src:hs2}
\begin{lstlisting}[language={Haskell}]
type CellID = Int

data Cell' = Str String | Number Double | EmptyCell
  deriving (Eq, Show, Generic)

-- I need to come up with a better name lol
data ForPiece = Code String | Refs [CellID]
  deriving (Eq, Show, Generic)

data FormulaError = FNoParse
                  | FCycleRefError
                  | FNoCache
                  | FListTypeError
                  | FMissingDepError
                  | FGhciError
                  | FTimeoutError
  deriving (Eq, Show, Generic)

data Formula = Formula { _code :: String
                       , _cache :: Either FormulaError Cell'
                       , _value :: Maybe [ForPiece]
                       }
  deriving (Eq, Show, Generic)

data Cell = Val {_cellV :: Cell'} | For {_cellF :: Formula}
  deriving (Eq, Show, Generic)

data Spreadsheet = SS { _sheet :: Gr Cell Int
                      , _selected :: Maybe CellID
                      , _logMessage :: Maybe String
                      }
  deriving(Eq, Show, Generic)
\end{lstlisting}

A Spreadsheet egy rekord típus, amelynek három mezője van. A \textit{selected} mező jelenti az aktuálisan kijelölt cellát. Ez a mező kerülhetett volna a globális állapotba is, azonban a tervezés korai fázisában másképp döntöttem, és már nem feltétlenül éri meg refaktorálni a kódot. A \textit{\_logMessage} mező tartalmazza a legutóbbi művelet kiértékeléséből származó szöveges (a GUI-ban a logra írandó) üzenetet.

A \textit{\_sheet} mező reprezentálja a tényleges számolótáblát. A számolótábla egy irányított gráf, aminek a csúcsai \textit{Cell} típusú értékekkel vannak címkézve. Az élek egész számokkal vannak címkézve. (Lehetett volna \textit{()}-tal is, azonban a használt gráfcsomag által biztosított legrövidebb utak implementációnak szüksége volt számszerű élcímkékre. Az implementációban minden él címkéje \textit{1}.) A gráfban minden csúcs a számolótábla egy cellájának felel meg. Egy \textit{A} csúcsból pontosan akkor megy él egy \textit{B} csúcsba, ha a \textit{B} csúcsban található cella kódja hivatkozik az \textit{A} csúcsban található cellára. 

Egy cella pontosan akkor szerepel a gráfban, ha nemüres vagy van olyan cella, amelyik hivatkozik rá. Így az üres és nemhivatkozott cellák tárolására nincs szükség.

A fent megadott gráfreprezentációnak két további előnye is van. Egyrészt könnyű körfigyelést implementálni, így elkerülve, hogy cellák körkörösen hivatkozzanak egymásra; másrészt ha módosul egy \textit{A} cella tartalma, akkor pontosan az \textit{A}-ból elérhető csúcsoknak megfelelő cellákat kell újra kiértékelni.

A gráfreprezentáció megvalósításához az \textit{fgl} csomagot használtam. A műveletek a \textit{DynGraph} típusosztály tetszőleges megvalósítására működnek. \textbf{EZ MÉG NEM IGAZ, DE MAJD ÁTÍROM} A \textit{Spreadsheet} típus definíciójában a PatriciaTree alapú \textit{Gr} típust használtam.

Egy cella tartalmát a \textit{Cell} típus fejezi ki. Egy cella tartalma lehet érték (\textit{Cell'}) vagy formula (\textit{Formula}). Az érték jelenleg háromféle lehet: szám (\textit{Double}), string vagy üres.

Ha egy cella formulát tartalmaz, az a háromelemű \textit{Formula} rekorddal reprezentáltatik. A \textit{\_code} mező tartalmazza a felhasználó által megadott kódot. Ez egy kényelmi funkció, hogy a kód megjelenítéséhez ne kelljen visszakonvertálni a reprezentációból. A \textit{\_cache} mezőben szerepel, hogy mi a formula legutóbbi kiértékelésének eredménye (ha egyáltalán már ki lett értékelve). A cache értéke vagy egy érték (\textit{Cell'}) vagy valamilyen hiba (\textit{FormulaError}). 

A \textit{\_value} jelenti a formula kódgeneráláshoz szükséges reprezentációját.  Ez a reprezentáció \textit{ForPiece}-ek (formuladarabok) listája. Egy formuladarab vagy egy kódrészlet (\textit{String}) vagy cellaazonosítók listája. A \textit{\_value} mezőről részletesebben lesz szó a \textit{Spreadsheet.Parser} és a \textit{Spreadsheet.CodeGeneration} modulok leírásában. 

A \textit{Formula} típushoz tartozik egy invariáns állítás: a program futása során egy \textit{Formula} mindig a következő oldalon leírt állapotok valamelyikében figyelhető meg.

\begin{table}
	\centering
	\begin{tabularx}{\textwidth}{ |l l l l| X |}
		\hline
		\multicolumn{4}{|c|}{Minta} & \multicolumn{1}{|c|}{Jelentés} \\
		\hline\hline
		Formula & \_ & (Left FNoParse) & Nothing & parseolási hiba \\
		\hline
		Formula & \_ & (Left FCycleRefError) & Nothing & sikeres parseolás, azonban a formula körkörös referenciákat adott volna a táblához \\
		\hline
		Formula & \_ & (Left FNoCache) & (Just \_) & sikeres parseolás, érvényes referenciák, de a formula még nem lett kiértékelve \\
		\hline
		Formula & \_ & (Left FListTypeError) & (Just \_) & \textbf{ALMA?} \\
		\hline
		Formula & \_ & (Left FMissingDepError) & (Just \_) & a formula nem értékelhető ki, mivel egy hivatkozott cella nem volt cache-elve. \\
		\hline
		Formula & \_ & (Left FGHCIError) & (Just \_) & a formula egyéb okokból nem volt kiértékelhető (pl. típushiba, Haskell szintaxishiba) \\
		\hline
		Formula & \_ & (Left FTimeoutError) & (Just \_) & időtúllépés miatt sikertelen kiértékelés, valószínűleg végtelen ciklus miatt \\
		\hline
		Formula & \_ & (Right cell') & (Just \_) & sikeres kiértékelés, az eredmény cell' \\
		\hline 
	\end{tabularx}
	\caption[Egy \textit{Formula} lehetséges állapotai]{Egy \textit{Formula} lehetséges állapotai}
	\label{tab:formula}
\end{table}

Érdemes megjegyezni, hogy ez az invariáns típuszinten is garantálható lett volna (feladat az olvasó számára!). A jelenlegi megoldás a korai tervezési fázis eredménye, a későbbiekben már erőforrásigényes lett volna refaktorálni a kódot.   

További megjegyzések a \textit{Spreadsheet} típussal kapcsolatban:
\begin{itemize}
	\item A \textit{Spreadsheet.Types} modul alapértelmezett nevű lenseket is exportál a \textit{Cell, Formula} és \textit{Spreadsheet} típusokhoz.
	\item A \textit{Spreadsheet.Types} modulban szereplő összes típus (a kivételek kivételével) példánya a \textit{Generic} és \textit{Serialize} típusosztályoknak (ez utóbbit a \textit{cereal} csomag exportálja). Erre a perzisztencia implementációjához van szükség.
\end{itemize}

\subsection{Spreadsheet.Parser}

A modul feladata egy a felhasználó által egy cellához megadott kód (\textit{String}) reprezentációjának (\textit{Cell}) előállítása. A modul egy függvényt exportál. (\textit{rep :: String -> Cell)}

Legyen a felhasználó által megadott kód \textit{str}. A \textit{rep} függvény az alábbi specifikáció szerint állítja elő a kód cellareprezentációját.

\begin{enumerate}
	\item Ha str = "", rep str = \textit{Val EmptyCell}
	\item Ha str illeszkedik a $(+|-|\varepsilon)DD^*(.D^+|\varepsilon))$ reguláris kifejezésre, ahol D=(0|1|2|3|4|5|6|7|8|9), akkor rep str = \textit{Val (Num n)}, ahol \textit{n} a literál által ábrázolt lebegőpontos szám. 
	\item Ha a fenti esetek egyike sem áll fent, és str nem (=C*) alakú (ahol C az összes karakterek halmaza), akkor rep str = \textit{Val (Str str)}
	\item Ha B a betűk halmaza (a \textit{Data.Char} modul \textit{isLetter} függvényének igazsághalmaza), C' = $C \backslash \{\S\}$ és str $(=((\S  BD^+:BD^+\S )|(\S BD^+\S )|(C'^+))^+)$ alakú, akkor a kód formulaként parseolható. rep str = \textit{Formula str (Left FNoCache) (Just ps)}, ahol ps definíciója alább szerepel.
	\item Ha egyik fenti eset sem áll fent, akkor a parseolás sikertelen. Ekkor rep str = \textit{Formula str (Left FNoParse) Nothing}
\end{enumerate}

Ha \textit{str} formulaként parseolható (fenti 4. eset), egy egyszerű szintaktikus elemzés segítségével kaphatjuk a reprezentációjának \textit{\_value} komponensét. A parser először elhagyja az \textit{=} karaktert. Ezután sorban parseol substringeket a szó elejéről az alábbi módon:
\begin{enumerate}
	\item Először megpróbálja cellahivatkozásként olvasni a soron következő részt: $((\S  BD^*:BD^*\S )|(\S BD^+\S ))$. Ha sikerült, a hivatkozást cellaazonosítók sorozatává konvertálja (lásd alább), és a kapott \textit{rs} azonosítólistát $Refs\ rs$ módon az eredménylista végére fűzi.
	\item Ha a soron következő substring nem olvasható cellahivatkozásként, akkor a parser végigolvassa a lehető leghosszabb $s = C'^+$ substringet, és az eredménylistához egy $Code\ s$-t ír.
\end{enumerate}

A cellahivatkozások feloldásához kihasználjuk, hogy a karakterek injektíven az egész számok halmazára képezhetők (az \textit{Enum} típusosztály műveleteivel). A kis- és nagybetűket nem különbözetjük meg. Emellett definiálunk egy \textit{Enum} példányt \textit{(Int,Int)} párokra. \textbf{AZT IS LE KÉNE SZÉPEN ÍRNI...} Jelölje $fromEnum^C$ a karaktert Int-té kódoló függvényt, és $fromEnum^P$ az \textit{(Int,Int)} párt Int-té kódoló függvény. Jelölje $a,b :: Int$ esetén $[a..b]$ az $a \le n \le b$ n egész számok rendezett listáját! Ekkor a cellahivatkozások feloldása az alábbiak szerint történik:
\begin{enumerate}
	\item Ha a hivatkozás $(\S BD^*\S )$ alakú, legyen \textit{b} a betű, és \textit{n} a számjegyek által reprezentált egész szám. Ekkor a kapott  \textit{rs} lista egyelemű. $rs\ = [fromEnum^P\ (fromEnum^C,n)]$
	\item Ha a hivatkozás $(\S  BD^*:BD^*\S )$ alakú, felbontható a \textit{:} mentén két egyszerű hivatkozásra. Legyenek a betűk $d_1$ és $d_2$, a számjegyek által reprezentált számok pedig rendre $n_1$ és $n_2$! Ekkor XD LOL 
\end{enumerate}

\subsection{Spreadsheet.Interface}

Ebben a modulban szerepelnek az \textit{App} komponens számára elérhető, a \textit{Spreadsheet} típushoz kapcsolódó függvények. Alább látható táblázatos formában a modul által exportált függvények feladata:

\begin{table}
	\centering
	\begin{tabularx}{\textwidth}{ |l|X|X|}
		\hline
		Függvény & Típus & Feladat \\
		\hline\hline
		emptySpreadSheet & Spreadsheet & üres számolótábla (0 csúcsú gráf, nincs kijelölt cella, nincs log üzenet) \\
		\hline
		getCellText & CellID -> Spreadsheet -> String & egy cellában megjelenítendő szöveg lekérdezése \\
		\hline
		getCellCode & getCellCode :: CellID -> Spreadsheet -> String & egy adott cellába legutóbb beírt kód lekérdezése \\
		\hline
		setCellState & CellID -> String -> Spreadsheet -> Spreadsheet & a megadott cella állapotának módosítása egy a felhasználó által megadott String alapján \\
		\hline
		cacheCell & CellID -> Either EvalError String -> Spreadsheet -> Spreadsheet & kiértékelés eredményének cachelése \\
		\hline
		getSelected & Spreadsheet -> Maybe CellID & kijelölt cella azonosítója \\
		\hline
		setSelected & CellID -> Spreadsheet -> Spreadsheet & kijelölt cella azonosítójának beállítása \\
		\hline 
		getLogMessage & Spreadsheet -> String & legutóbbi log üzenet lekérdezése \\
		\hline
	\end{tabularx}
	\caption[A \textit{Spreadsheet.Interface} által exportált függvények]{A \textit{Spreadsheet.Interface} által exportált függvények}
	\label{tab:interface}
\end{table}

\subsubsection{setCellState}

A \textit{setCellState} függvény feladata, hogy a megadott cellaazonosítóhoz tartozó csúcsban lévő cella állapotát a felhasználó által megadott \textit{String}-nek megfelelően módosítsa, valamint felülírja a \textit{\_logMessage} mező tartalmát a múvelet sikerességétől függően.

Ehhez szükség van a megadott \textit{String} \textit{Cell} reprezentációjára, amit a \textit{Spreadsheet.Parser} modul által exportált \textit{rep} függvény számít ki. A kapott reprezentáció alapján az alább leírtaknak megfelelően viselkedik a függvény:

\begin{enumerate}
	\item Ellenőrzi, hogy a cella állapotának megváltoztatásával keletkeznék-e 		körkörös referencia. Pontosan akkor keletkeznék, ha a megváltoztatandó $c$ 	azonosítójú cellához tartozó csúcsba bemenő összes él kitörlésével keletkezett gráfban van olyan $n$ azonosítójú csúcs, hogy $c$ kódja hivatkozik $n$-re és a gráfban már van $c \rightarrow n$ út. (Ez utóbbi feltétel azt jelenti, hogy az $n$ cella értéke függ $c$ értékétől.) Ezt a feltételt az \textit{isLegal} függvény ellenőrzi. Érdemes megjegyezni, hogy ilyen hiba csak akkor fordulhat elő, ha a kapott reprezentációnk egy formula.
	\item Amennyiben az \textit{isLegal} eredménye \textit{False}, a $c$ csúcsban levő cella reprezentációja \textit{For (Formula str' (Left FCycleRefError) Nothing)} lesz, ahol \textit{str'} a paraméterként kapott \textit{String}. A \textit{\_logMessage} mezőbe egy hibaüzenet kerül.
	\item Amennyiben az \textit{isLegal} függvény \textit{True} eredményt ad, a gráfból kitöröltetik az összes $c$-be menő él, és új $c$-be menő élek kerülnek behúzásra a $c$ kódja által referált celláknak megfelelő csúcsokból. (Ezeket a \textit{references} függvény számolja a reprezentációból.) A \textit{\_logMessage} mező tartalma egy sikert jelző üzenet lesz.
\end{enumerate}

\textbf{ITT MÉG KÉNE ÍRNI TALÁN A FELHASZNÁLT SEGÉDFÜGGVÉNYEKRŐL?}

\subsubsection{cacheCell}

\subsection{Spreadsheet.CodeGeneration}

\subsection{Eval.EvalMain}

A modul által exportált \textit{evalMain} függvény biztosítja a kifejezések GHCi-ben való kiértékelését végző szál főprogramját. A szál az alábbiak szerint működik:

\begin{enumerate}
	\item Várakozik, ameddig a globális állapot \textit{evalControl} mezőjének \textit{eCommand} változójába egy GHCi utasítást nem ír a fő szál.
	\item Kiüríti a változót, és kiértékeli a kapott utasítást a GHCi-ben.
	\item Ha egy megadott idő után nem ér véget a kiértékelés (jelenleg 1 másodperc), lekérdezi a GHCi folyamathoz tartozó PID-et, majd megkeresi annak a gyerekfolyamatát (\textit{childPid}), és az \textit{eResult} változóba \textit{Left\ childPid}-et ír. Ezt a folyamatot aztán a fő szál fogja kilőni.
	\item Amennyiben időben véget ér a kiértékelés, a GHCi által eredményül adott sorok \textit{result} listáját \textit{Right\ result} módon az \textit{eResult} változóba írja.
\end{enumerate}

A timeout utáni viselkedés bonyolultsága egy szerencsétlen helyzet eredménye. A magyarázathoz meg kell ismerni a \textit{ghcid} csomag által biztosított GHCi interfészt. A \textit{startGhci} függvény a dokumentáció alapján elindít egy GHCi háttérfolyamatot, amellyel innentől egy megadott szálról kell interaktálni (a megszakítást kivéve). A valóságban azonban azt tapasztaltam, hogy két folyamatot indít el, amelyek közül az egyik gyereke a másiknak. 

Időtúllépés esetén meg kell állítani a háttérben futó számítást. Erre szolgálna az \textit{interrupt} függvény, ami egy \textit{SIGINT} jelzést küld a GHCi folyamatnak. A GHCi folyamat azonban bizonyos esetekben ezt kimaszkolja, ilyenkor a számítást nem lehetséges megszakítani. \textbf{IDE KÉNE LINK ERRŐL A DISKURZUSRÓL} A GHCi leállítására szolgáló \textit{stopGhci} függvény pedig csak  az egyik (a szülő) folyamatot terminálja a \textit{startGhci} által indított két folyamatból. A másik folyamat pedig tovább folytatja a számítást. Az alkalmazás egy Haskell szálat tartalmazó verziójában ez kiéheztette az fő folyamatot. 

Ezért van szükség arra, hogy a kiértékelés külön szálon fusson. Ugyanis időtúllépés esetén a fő szál, miután ütemezésre kerül, a kapott PID alapján a lehető legagresszívabban (\textit{SIGKILL}) terminálja a második GHCi folyamatot. Ez a tapasztalat szerint az első folyamatnak is véget vet. Ezután új GHCi folyamat indítható.

A fenti megoldást a szükség szülte, és tapasztalatok alapján, gyakran próbálgatás útján állt össze. Nem ismert, hogy miért indít a \textit{startGhci} két folyamatot. (Egy "rendes" GHCi folyamathoz például csak egy PID tartozik.) A megoldás az én számítógépemen, Ubuntu 20.04 LTS operációs rendszer mellett működött, de nincs rá garancia, hogy más Linux rendszer (vagy akár egy másik számítógép!) esetén működni fog. (A működés feltétele, hogy ütemezésre kerüljön a fő szál.) Ráadásul csak e miatt az interakció miatt kellett konkurrenciát adni az alkalmazáshoz. Valódi hatékonyságot ezzel nem nyertünk, hiszen az egyik szál mindig blokkolt állapotban lesz. (Mivel mindkét szál a fogyasztóként hozzá tartozó \textit{MVar}-ra várakozik, ha éppen a másik szál dolgozik.)

A gyerekfolyamat megtalálásához a program rendszerhívást hajt végre, a \textit{pgrep} parancsot használja \textit{-P} kapcsolóval.

\subsection{Eval.Ghci}

A modul fő feladata, hogy kiértékeljen egy GHCi parancsot, és az eredményt értelmezze. Emellett lehetőséget biztosít a modulok és keresési útvonalak újratöltésére a globális konfiguráció alapján (\textit{EvalConfig}).

\begin{table}
	\centering
	\begin{tabularx}{\textwidth}{ |X|X|}
		\hline
		Függvény & Típus \\
		\hline\hline
		execGhciCommand & String -> ReaderT EvalControl IO (Either EvalError String) \\
		\hline
		loadModules & ReaderT EvalControl IO () \\
		\hline
	\end{tabularx}
	\caption[Az \textit{Eval.Ghci} által exportált függvények]{Az \textit{Eval.Ghci} által exportált függvények}
	\label{tab:interface}
\end{table}

A kiértékelés folyamata a (nem exportált) \textit{execG} függvényben van leírva, és az alábbi módon zajlik:
\begin{enumerate}
	\item A paraméterként kapott parancs a \textit{eCommand} változóba kerül.
	\item Kiolvasásra kerül az eredmény az \textit{eResult} változóból.
	\item Ha az eredmény \textit{Left\ pid}, a kapott PID-hez tartozó folyamat terminálásra kerül, és a kiértékelés eredménye \textit{Left\ ETimeoutError}. Új GHCi folyamat indul, és a hivatkozása bekerül a globális állapot \textit{evalConfig} mezőjének \textit{eGhci} mezőjébe.
	\item Ha az eredmény \textit{Right\ result}, ez a kiértékelés eredménye. \textit{result :: [String]} a GHCi által eredményül adott sorok listája.
\end{enumerate}

Az exportált \textit{execGhciCommand} függvény ezt a viselkedést egészíti ki egy extra ellenőrzéssel.
\begin{enumerate}
	\item Ha az \textit{execG} eredménye \textit{Left\ ETimeoutError}, akkor ez az eredmény.
	\item Ha az \textit{execG} eredménye \textit{Right\ results}:
	\begin{itemize}
		\item Ha \textit{results} üres, az eredmény \textit{Right\ ""}
		\item Ha \textit{results} egyelemű, az eredmény \textit{Right\ (head (results))}
		\item Ha \textit{results} több elemű, akkor a GHCi több sornyi eredményt adott vissza. Ezt a függvény hibának tekinti, és az eredmény \textit{Left (EGhciError results)}
	\end{itemize}
\end{enumerate}

A \textit{loadModules} akció beállítja a globális állapot \textit{evalControl} mezőjének \textit{eConfig} mezője alapján az elérési utakat, majd betölti a megadott modulokat. A korábban betöltött modulokat először kitölti (\textit{:m}). Ilyenkor a felhasználó által közvetlenül a GHCi-ba megadott definíciók is elvesznek. Az akció betölti az \textit{Empty} modult is, ami szükséges ahhoz, hogy működjék az \textit{€} minta, amit a cellablokkok kezeléséhez biztosít a program.